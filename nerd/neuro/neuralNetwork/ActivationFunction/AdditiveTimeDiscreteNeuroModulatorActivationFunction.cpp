/***************************************************************************
 *   NERD - Neurodynamics and Evolutionary Robotics Development Toolkit    *
 *                                                                         *
 *   University of Osnabrueck, Germany                                     *
 *   Institute of Cognitive Science                                        *
 *   Neurocybernetics Group                                                *
 *   http://www.ikw.uni-osnabrueck.de/~neurokybernetik/                    *
 *                                                                         *
 *   Project homepage: nerd.x-bot.org                                      *
 *                                                                         *
 *   Copyright (C) 2008 - 2013 by the Neurocybernetics Group Osnabr√ºck     *
 *   Contact: Christian Rempis                                             *
 *   christian.rempis@uni-osnabrueck.de                                    *
 *   Contributors: see contributors.txt in the nerd main directory.        *
 *                                                                         *
 *                                                                         *
 *   Acknowledgments:                                                      *
 *   The NERD Toolkit is part of the EU project ALEAR                      *
 *   (Artificial Language Evolution on Autonomous Robots) www.ALEAR.eu     *
 *   This work was funded (2008 - 2011) by EU-Project Number ICT 214856    *
 *                                                                         *
 *                                                                         *
 *   License Agreement:                                                    *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   Publications based on work using the NERD kit have to state this      *
 *   clearly by citing the NERD homepage and the NERD overview paper.      *  
 ***************************************************************************/

#include "AdditiveTimeDiscreteNeuroModulatorActivationFunction.h"
#include <QListIterator>
#include "Network/Synapse.h"
#include "Network/Neuron.h"
#include <iostream>
#include "Core/Core.h"
#include <Math/Math.h>
#include <Network/NeuralNetworkManager.h>
#include <Network/Neuro.h>
#include <ModularNeuralNetwork/ModularNeuralNetwork.h>

using namespace std;

namespace nerd {

AdditiveTimeDiscreteNeuroModulatorActivationFunction::AdditiveTimeDiscreteNeuroModulatorActivationFunction()
	: NeuroModulatorActivationFunction("ModulatorCell"), mOwner(0)
{
	
	mStimulationState = new DoubleValue();
	mCurrentConcentration = new DoubleValue();
	
	addObserableOutput("Activation", mStimulationState);
	addObserableOutput("Concentration", mCurrentConcentration);
	
	mModulatorType = new IntValue(1);
	mModulatorType->setDescription("The moduator type produced by this modulator cell (an id)");
	mDiffusionModus = new IntValue(1);
	mDiffusionModus->setDescription("The modulator diffision model:\n"
							"1: Linear change, homogeneous distribution\n"
							"2: Linear change, linear distribution\n");
	mMaxConcentration = new DoubleValue(1.0);
	mMaxConcentration->setDescription("The maximum concentration of the modulator type that can be generated by this cell.");
	mTriggerRange = new RangeValue(0.9, 1.0);
	mTriggerRange->setDescription("The neuron activation range in which the modulator cell is stimulated.");
	mStimulationIncrements = new RangeValue(0.001, 0.01, false);
	mStimulationIncrements->setDescription("Gain (Drop) of the activation state per step when the cell is simulated (not stimulated).");
	mStimulationThreshold = new DoubleValue(0.95);
	mStimulationThreshold->setDescription("Separates the cell activation state into a reduction (< threshold) and a production (>= threshold) modus.");
	mConcentrationIncrements = new RangeValue(0.001, 0.01, false);
	mConcentrationIncrements->setDescription("Gain (Drop) of the modulator concentration per step when the cell is in production (reduction) mode.");
	mAreaIncrements = new RangeValue(1.0, 0.0, false);
	mAreaIncrements->setDescription("Gain (Drop) or the modulator distribution area per step when the cell is in production (reduction) mode.");
	mAreaRadius = new DoubleValue(1000.0);
	mAreaRadius->setDescription("The maximal radius of the modulator distribution area.");
	mReferenceModule = new ULongLongValue(0);
	mReferenceModule->setDescription("The id of an (optional) reference module, whose area is used os modulator distribution area.");
	
	addParameter("ModType", mModulatorType);
	addParameter("DiffusionModus", mDiffusionModus);
	addParameter("MaxConcentration", mMaxConcentration);
	addParameter("TriggerRange", mTriggerRange);
	addParameter("StimGainDrop", mStimulationIncrements);
	addParameter("StimThreshold", mStimulationThreshold);
	addParameter("ConGainDrop", mConcentrationIncrements);
	addParameter("AreaGainDrop", mAreaIncrements);
	addParameter("AreaRadius", mAreaRadius);
	addParameter("RefModule", mReferenceModule);
}

AdditiveTimeDiscreteNeuroModulatorActivationFunction::AdditiveTimeDiscreteNeuroModulatorActivationFunction(
			const AdditiveTimeDiscreteNeuroModulatorActivationFunction &other)
	: Object(), ValueChangedListener(), ObservableNetworkElement(other), NeuroModulatorElement(other), 
		NeuroModulatorActivationFunction(other), mOwner(0)
{
	
	mStimulationState = new DoubleValue();
	mCurrentConcentration = new DoubleValue();
	
	addObserableOutput("Activation", mStimulationState);
	addObserableOutput("Concentration", mCurrentConcentration);
	
	mModulatorType = dynamic_cast<IntValue*>(getParameter("ModType"));
	mDiffusionModus = dynamic_cast<IntValue*>(getParameter("DiffusionModus"));
	mMaxConcentration = dynamic_cast<DoubleValue*>(getParameter("MaxConcentration"));
	mTriggerRange = dynamic_cast<RangeValue*>(getParameter("TriggerRange"));
	mStimulationIncrements = dynamic_cast<RangeValue*>(getParameter("StimGainDrop"));
	mStimulationThreshold = dynamic_cast<DoubleValue*>(getParameter("StimThreshold"));
	mConcentrationIncrements = dynamic_cast<RangeValue*>(getParameter("ConGainDrop"));
	mAreaIncrements = dynamic_cast<RangeValue*>(getParameter("AreaGainDrop"));
	mAreaRadius = dynamic_cast<DoubleValue*>(getParameter("AreaRadius"));
	mReferenceModule = dynamic_cast<ULongLongValue*>(getParameter("RefModule"));
}

AdditiveTimeDiscreteNeuroModulatorActivationFunction::~AdditiveTimeDiscreteNeuroModulatorActivationFunction() {
}

ActivationFunction* AdditiveTimeDiscreteNeuroModulatorActivationFunction::createCopy() const {
	return new AdditiveTimeDiscreteNeuroModulatorActivationFunction(*this);
}

QString AdditiveTimeDiscreteNeuroModulatorActivationFunction::getName() const {
	return NeuroModulatorActivationFunction::getName();
}

void AdditiveTimeDiscreteNeuroModulatorActivationFunction::valueChanged(Value *value) {
	NeuroModulatorActivationFunction::valueChanged(value);
	
	if(value == mModulatorType) {
		mNeuroModulator->reset(mOwner);
		configureNeuroModulation();
	}
	else if(value == mDiffusionModus
		|| value == mMaxConcentration
		|| value == mTriggerRange
		|| value == mStimulationIncrements
		|| value == mStimulationThreshold
		|| value == mConcentrationIncrements
		|| value == mAreaIncrements
		|| value == mAreaRadius
		|| value == mReferenceModule)
	{
		configureNeuroModulation();
	}
}



void AdditiveTimeDiscreteNeuroModulatorActivationFunction::reset(Neuron *neuron) {
	if(mNeuroModulator == 0) {
		setNeuroModulator(new NeuroModulator());
	}
	mOwner = neuron;
	NeuroModulatorActivationFunction::reset(neuron);
	configureNeuroModulation();
	updateObservables();
}


double AdditiveTimeDiscreteNeuroModulatorActivationFunction::calculateActivation(Neuron *owner) {
	mOwner = owner;
	NeuroModulatorActivationFunction::calculateActivation(owner);
	if(owner == 0) {
		return 0.0;
	}
	double activation = owner->getBiasValue().get();

	QList<Synapse*> synapses = owner->getSynapses();
	for(QListIterator<Synapse*> i(synapses); i.hasNext();) {
		activation += i.next()->calculateActivation();
	}
	
	updateObservables();

	return activation;
}

bool AdditiveTimeDiscreteNeuroModulatorActivationFunction::equals(ActivationFunction *activationFunction) const {
	if(NeuroModulatorActivationFunction::equals(activationFunction) == false) {
		return false;
	}
	AdditiveTimeDiscreteNeuroModulatorActivationFunction *af =
 			dynamic_cast<AdditiveTimeDiscreteNeuroModulatorActivationFunction*>(activationFunction);

	if(af == 0) {
		return false;
	}
	if(mModulatorType->get() != af->mModulatorType->get()
		|| mDiffusionModus->get() != af->mDiffusionModus->get()
		|| Math::compareDoubles(mMaxConcentration->get(), 0.0000001) == false
		|| mTriggerRange->get().equals(af->mTriggerRange->get(), 8) == false
		|| mStimulationIncrements->get().equals(af->mStimulationIncrements->get(), 8), false
		|| mStimulationThreshold->get() != af->mStimulationThreshold->get()
		|| mConcentrationIncrements->get().equals(af->mConcentrationIncrements->get(), 8) == false
		|| mAreaIncrements->get().equals(af->mAreaIncrements->get(), 8) == false
		|| mAreaRadius->get() != af->mAreaRadius->get()
		|| mReferenceModule->get() != af->mReferenceModule->get())
	{
		return false;
	}
	
	return true;
}

void AdditiveTimeDiscreteNeuroModulatorActivationFunction::configureNeuroModulation() {
	//TODO This combination is currently reflected by the diffusion modus. Once there are more configurations, 
	//this part has to be adapted!
	mNeuroModulator->setDistributionModus(mModulatorType->get(), mDiffusionModus->get());
	mNeuroModulator->setUpdateModus(mModulatorType->get(), 1); 
	
	mNeuroModulator->setMaxConcentration(mModulatorType->get(), mMaxConcentration->get());
	mNeuroModulator->setConcentration(mModulatorType->get(), 0.0, mOwner);
	mNeuroModulator->setLocalAreaRect(mModulatorType->get(), mAreaRadius->get() * 2.0, mAreaRadius->get() * 2.0, Vector3D(), true);
	
	//check if there is a reference module to be set!
	if(mReferenceModule->get() > 0) {
		NeuroModule *module = 0;
		if(mOwner != 0) {
			ModularNeuralNetwork *net = dynamic_cast<ModularNeuralNetwork*>(mOwner->getOwnerNetwork());
			if(net != 0) {
				module = ModularNeuralNetwork::selectNeuroModuleById(mReferenceModule->get(), net->getNeuroModules());
			}
			if(module == 0) {
				Core::log("AdditiveTimeDiscreteNeuroModulatorActivationFunction: Could not find reference module with id " 
							+ QString::number(mReferenceModule->get()), true);
			}
		}
		mNeuroModulator->setAreaReferenceModule(mModulatorType->get(), module);
	}
	
	//set the parameters of update modus 1 (current default)
	QList<double> parameters;
	parameters.append(mStimulationIncrements->getMin());  //stimulation gain
	parameters.append(mStimulationIncrements->getMax());  //stimulation drop
	parameters.append(mStimulationThreshold->get());
	parameters.append(mConcentrationIncrements->getMin()); //concentration  gain
	parameters.append(mConcentrationIncrements->getMax()); //concentration  drop
	parameters.append(mAreaIncrements->getMin());  //area gain
	parameters.append(mAreaIncrements->getMax());  //area drop
	parameters.append(mTriggerRange->getMin()); //triggers range min
	parameters.append(mTriggerRange->getMax()); //triggers range max
	parameters.append(mAreaRadius->get() * 2.0); //max width (obsolete?)
	parameters.append(mAreaRadius->get() * 2.0); //max height (obsolete?)
	parameters.append(0); //modus (currrently there is only one modus)
	mNeuroModulator->setUpdateModusParameters(mModulatorType->get(), parameters);
}

void AdditiveTimeDiscreteNeuroModulatorActivationFunction::updateObservables() {
	
	if(mNeuroModulator == 0) {
		mCurrentConcentration->set(0.0);
		mStimulationState->set(0.0);
		return;
	}

	mCurrentConcentration->set(mNeuroModulator->getConcentration(mModulatorType->get(), mOwner));
	
	double stimulation = 0.0;
	
	int modus = mNeuroModulator->getUpdateModus(mModulatorType->get());
	if(modus == 1) {
		QList<double> vars = mNeuroModulator->getUpdateModusVariables(mModulatorType->get());
		if(vars.size() > 0) {
			stimulation = vars.at(0);
		}
	}
	mStimulationState->set(stimulation);
}


}


